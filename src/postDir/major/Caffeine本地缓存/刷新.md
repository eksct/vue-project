```java
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumSize(10_000)
    .expireAfterWrite(Duration.ofMinutes(5))
    .refreshAfterWrite(Duration.ofMinutes(1))
    .build(key -> createExpensiveGraph(key));
```
可以通过`LoadingCache.refresh(K)`方法，异步为key对应的缓存元素刷新一个新的值。
在刷新的时候如果查询缓存元素，其旧值将仍被返回，直到该元素的刷新完毕后结束后才会返回刷新后的新值。（毕竟是异步的）
`refreshAfterWrite` 的作用是在key被访问时才会进行刷新操作。
将`refreshAfterWrite`与`refreshAfterWrite`组合使用则可以避免缓存的无期限存在，且保证频繁访问的key都持有新值。
可以通过覆盖重写 `CacheLoader.reload(K, V)` 方法进行增量更新操作。