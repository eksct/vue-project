Caffeine 是一款高性能的本地缓存库，针对Java 8进行了优化，用以替代原有的Guava Cache。相较于其他缓存库，Caffeine提供了更优的性能表现以及更多的特性选项，如自动加载、过期策略等。

👇复制于github文档：
Caffeine是一个基于Java8开发的提供了[近乎最佳](https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN)命中率的[高性能](https://github.com/ben-manes/caffeine/wiki/Benchmarks-zh-CN)的缓存库。

缓存和[ConcurrentMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html)有点相似，但还是有所区别。最根本的区别是[ConcurrentMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html)将会持有所有加入到缓存当中的元素，直到它们被从缓存当中手动移除。但是，Caffeine的缓存`Cache` 通常会被配置成自动驱逐缓存中元素，以限制其内存占用。在某些场景下，`LoadingCache`和`AsyncLoadingCache` 因为其自动加载缓存的能力将会变得非常实用。

Caffeine提供了灵活的构造器去创建一个拥有下列特性的缓存：

- [自动加载](https://github.com/ben-manes/caffeine/wiki/Population-zh-CN)元素到缓存当中，异步加载的方式也可供选择
- 当达到最大容量的时候可以使用基于[就近度和频率](https://github.com/ben-manes/caffeine/wiki/Efficiency-zh-CN)的算法进行[基于容量的驱逐](https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%AE%B9%E9%87%8F)
- 将根据缓存中的元素上一次访问或者被修改的时间进行[基于过期时间的驱逐](https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4)
- 当向缓存中一个已经过时的元素进行访问的时候将会进行[异步刷新](https://github.com/ben-manes/caffeine/wiki/Refresh-zh-CN)
- key将自动被[弱引用](https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8)所封装
- value将自动被[弱引用或者软引用](https://github.com/ben-manes/caffeine/wiki/Eviction-zh-CN#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8)所封装
- 驱逐(或移除)缓存中的元素时将会进行[通知](https://github.com/ben-manes/caffeine/wiki/Removal-zh-CN)
- [写入传播](https://github.com/ben-manes/caffeine/wiki/Writer-zh-CN)到一个外部数据源当中
- 持续计算缓存的访问[统计指标](https://github.com/ben-manes/caffeine/wiki/Statistics-zh-CN)

为了提高集成度，扩展模块提供了[JSR-107 JCache](https://github.com/ben-manes/caffeine/wiki/JCache-zh-CN)和[Guava](https://github.com/ben-manes/caffeine/wiki/Guava-zh-CN)适配器。JSR-107规范了基于Java 6的API，在牺牲了功能和性能的代价下使代码更加规范。Guava的Cache是Caffeine的原型库并且Caffeine提供了适配器以供简单的迁移策略。

- **驱逐** 缓存元素因为策略被移除 ^ca1c8f
- **失效** 缓存元素被手动移除
- **移除** 由于驱逐或者失效而最终导致的结果