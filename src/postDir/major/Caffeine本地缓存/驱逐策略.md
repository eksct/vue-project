- **驱逐** 缓存元素因为策略被移除
Caffeine 提供了三种驱逐（过期）策略，分别是基于容量，基于时间和基于引用三种类型。
### 基于容量
```java
// 基于缓存内的元素个数进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumSize(10000)
    .build(key -> createExpensiveGraph(key));

// 基于缓存内元素权重进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .maximumWeight(10000)
    .weigher((Key key, Graph graph) -> graph.vertices().size())
    .build(key -> createExpensiveGraph(key));
```
使用`Caffeine.maximumSize(long)`指定缓存最大大小。
缓存将会尝试通过基于[就近度和频率的算法](https://github.com/ben-manes/caffeine/wiki/Efficiency)来驱逐掉不会再被使用到的元素。
另一种情况，你的缓存可能中的元素可能存在不同的“权重”
也许需要借助`Caffeine.weigher(Weigher)` 方法来界定每个元素的权重并通过 `Caffeine.maximumWeight(long)`方法来界定缓存中元素的总权重来实现。
在基于权重驱逐的策略下，一个缓存元素的权重计算是在其创建和更新时，此后其权重值都是静态存在的，在两个元素之间进行权重的比较的时候，并不会根据进行相对权重的比较。
### 基于时间
```java
// 基于固定的过期时间驱逐策略
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfterAccess(5, TimeUnit.MINUTES)
    .build(key -> createExpensiveGraph(key));
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .build(key -> createExpensiveGraph(key));

// 基于不同的过期驱逐策略
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .expireAfter(Expiry.creating((Key key, Graph graph) -> 
        Duration.between(Instant.now(), graph.creationDate().plusHours(5))))
    .build(key -> createExpensiveGraph(key));
```
Caffeine提供了三种方法进行基于时间的驱逐:
- `expireAfterAccess(long, TimeUnit):`缓存元素在读写后，没有在固定时间内再次访问会被认定为过期项。 最好是将缓存元素绑定在一个`session`上，当`session`不活跃时，缓存元素过期。
- `expireAfterWrite(long, TimeUnit):`创建或更新后，在指定时间内过期。
- `expireAfter(Expiry):` 自定义缓存过期逻辑。
可以通过在你的Cache构造器中通过`Scheduler`接口和`Caffeine.scheduler(Scheduler)` 方法去指定一个调度线程。使用Java 9以上版本的用户可以选择`Scheduler.systemScheduler()`利用系统范围内的调度线程。
测试基于时间的驱逐策略的时候，使用`Ticker`接口和 `Caffeine.ticker(Ticker)`方法在你的Cache构造器中去指定一个时间源。
### 基于引用
```java
// 当key和缓存元素都不再存在其他强引用的时候驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .weakKeys()
    .weakValues()
    .build(key -> createExpensiveGraph(key));

// 当进行GC的时候进行驱逐
LoadingCache<Key, Graph> graphs = Caffeine.newBuilder()
    .softValues()
    .build(key -> createExpensiveGraph(key));
```
Caffeine 允许你配置你的缓存去让GC去帮助清理缓存当中的元素，其中key支持弱引用，而value则支持弱引用和软引用。记住 `AsyncCache`不支持软引用和弱引用。
`Caffeine.weakKeys()` 在保存key的时候将会进行弱引用。当 key 没有被其他强引用引用时，会被 GC 回收，缓存项也随之清除。**因为 GC 比较的是引用对象本身**，所以 key 的比较方式不再是 `.equals()`，而是 `==`（**引用地址相等**）。
`Caffeine.weakValues()`在保存value的时候将会使用弱引用。当 value 没有被其他地方强引用引用时，会被 GC 回收。**因为 GC 比较的是引用对象本身**，所以 value 的比较方式不再是 `.equals()`，而是 `==`（**引用地址相等**）。
`Caffeine.softValues()`在保存value的时候将会使用软引用。回收顺序基于 LRU（最近最少使用）策略。
**在 JVM 内存紧张时，GC 会自动回收软引用对象**，释放内存。所以存在软引用回收时机不可控，而且比较耗性能，**不建议频繁使用**。**因为 GC 比较的是引用对象本身**，所以 value 的比较方式不再是 `.equals()`，而是 `==`（**引用地址相等**）。