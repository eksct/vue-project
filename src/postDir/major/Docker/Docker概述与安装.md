## 1. 为什么需要 Docker？

在传统开发到运维的过程中，经常会遇到 **环境不一致** 的问题：

- 开发环境可以跑，测试环境报错；
    
- 测试环境 OK，上线后生产环境出问题；
    
- 迁移到新平台时，需要重新配置环境。
    

**Docker 的出现，解决了这些问题**：

- 将应用和运行环境 **一起打包** 成镜像；
    
- 部署时直接运行镜像，无需额外配置；
    
- 支持跨平台迁移，做到 **“一次打包，到处运行”**。
    

---

## 2. Docker 工作流程

1. 开发完成后，将应用和依赖环境打包成 **镜像 (Image)**
    
    - Java 项目示例：`java -jar app.jar`
        
    - 打包时将 JDK、依赖环境一并打入镜像。
        
2. 将镜像上传到 **Docker 仓库 (Registry)**
    
    - 类似于 “应用商店”。
        
3. 部署时，直接从仓库下载镜像并运行容器：
    
    - `docker run your-image`
        
    - 即可在任意平台运行，无需额外配置。
        

---

## 3. Docker vs 虚拟机

|特性|虚拟机 (VM)|Docker 容器|
|---|---|---|
|系统开销|每个 VM 需要完整操作系统|容器共享宿主机内核|
|启动速度|分钟级|秒级|
|资源利用率|相对较低|更高效，密度更大|
|隔离性|完全隔离（硬件级）|进程级隔离（文件系统独立）|
|跨平台能力|受限|一次打包，到处运行|

**总结**：Docker 是 **内核级虚拟化**，相比虚拟机更轻量，资源利用率更高。

---

## 4. Docker 在 DevOps 中的优势

1. **更快速的交付与部署**
    
    - 传统方式：繁琐的安装文档 + 环境配置；
        
    - Docker：打包镜像 → 发布测试 → 一键运行。
        
2. **更便捷的升级与扩缩容**
    
    - 部署像“搭积木”一样：
        
        - 镜像相同，容器可快速扩展到服务器 A、B。
            
3. **更简单的系统运维**
    
    - 开发、测试、生产环境高度一致；
        
    - 降低环境差异带来的问题。
        
4. **更高效的资源利用**
    
    - 内核级虚拟化，一个物理机可运行大量容器；
        
    - 充分压榨服务器性能。
        

---

## 5. 总结

- **Docker 是容器化技术**，区别于传统虚拟化，不需要安装完整系统；
    
- 容器之间相互隔离，拥有独立的文件系统和运行环境；
    
- 结合 DevOps 流程，Docker 极大提升了 **应用交付效率、环境一致性和资源利用率**。

---
# 安装 Docker

## 1. Windows 系统

在 Windows 上，可以通过 **Docker Desktop** 进行安装：

- 进入 [Docker 官方下载页面](https://www.docker.com/products/docker-desktop/)
    
- 下载并安装 **Docker Desktop for Windows**
    
- 安装完成后，即可通过 `docker version` 验证安装结果
    

---

## 2. Linux 系统（以 Ubuntu 为例）

### 系统要求

- 支持的系统版本：
    
    - Ubuntu **22.04 (LTS)**、**24.04 (LTS)**
        
    - 或最新非 LTS 版本
        
- 系统架构：64 位

### 安装步骤

1. 更新软件源
   
```bash
   sudo apt-get update
```
   
2. 安装 Docker Desktop
```bash
   sudo apt-get install ./docker-desktop-amd64.deb
```
   
3. 验证安装是否成功
```bash
   docker version
```


Docker是怎么工作的?
Docker 是一个 (lient-Server 结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问!
DockerServer 接收到 Docker-Client的指令，就会执行这个命令!