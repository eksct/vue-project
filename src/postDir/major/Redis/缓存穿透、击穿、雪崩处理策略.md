这是 Redis 在实际生产中**三大常见缓存问题**：**缓存穿透、缓存击穿、缓存雪崩**，如果不处理好，轻则性能抖动，重则数据库崩溃。下面我详细给你梳理这三者的**定义 + 产生原因 + 解决方案（附代码/设计思路）**。

---

# 🔍 一、缓存穿透（Cache Penetration）

### ✅ 概念：

请求的数据 **在缓存中不存在，数据库中也不存在**，每次都会去查数据库，导致数据库压力剧增。

---

### 🚨 场景：

- 用户请求一个 `userId = -9999` 的数据，Redis 没有，数据库也没有。
    
- 每次请求都直达数据库，绕过缓存。
    

---

### ✅ 解决方案：

#### ✅ 1. 缓存空值（推荐）

当数据库返回空结果时，也写入缓存：

```java
// 查询缓存
String val = redis.get(key);
if (val == null) {
    Object dbVal = db.query(key);
    if (dbVal == null) {
        redis.setex(key, "NULL", 60); // 缓存空值，过期时间短
        return null;
    } else {
        redis.set(key, dbVal, 3600);
        return dbVal;
    }
}
```

#### ✅ 2. 使用布隆过滤器（大规模穿透）

用布隆过滤器维护所有合法 key 的集合，提前拦截非法请求。

```java
if (!bloomFilter.mightContain(key)) {
    return null; // 根本不可能存在
}
```

---

# ⚡ 二、缓存击穿（Cache Breakdown）

### ✅ 概念：

**某个热点 key 失效的瞬间**，大量请求同时到来，请求全打在数据库上，瞬间把数据库压垮。

---

### 🚨 场景：

- 某个热点商品秒杀信息失效，几万请求瞬间访问 DB。
    

---

### ✅ 解决方案：

#### ✅ 1. 加互斥锁（推荐）

防止大量请求同时回源数据库：

```java
if (redis.get(key) == null) {
    // 分布式锁
    if (tryLock("lock:" + key)) {
        try {
            // 只有一个线程查库并写缓存
            Object dbData = db.query(key);
            redis.set(key, dbData, 60 * 60);
        } finally {
            releaseLock("lock:" + key);
        }
    } else {
        // 其他线程等待或快速失败
        Thread.sleep(50);
        return redis.get(key);
    }
}
```

> 可以用 Redisson 提供的 `RLock` 实现分布式锁。

#### ✅ 2. 永不过期 + 异步更新（缓存预热/刷新策略）

- 热点数据设置为永不过期，后台定时刷新。
    

---

# 🌨 三、缓存雪崩（Cache Avalanche）

### ✅ 概念：

**大量缓存同一时间过期或失效**，导致请求集中打到数据库，系统崩溃。

---

### 🚨 场景：

- 系统重启后所有缓存一起失效
    
- 所有 key 设置了同样的 TTL，到了就一起失效
    

---

### ✅ 解决方案：

#### ✅ 1. 设置过期时间时加随机值（推荐）

```java
redis.set(key, value, 3600 + random.nextInt(300));
```

> 避免所有 key 同时过期，缓解压力。

#### ✅ 2. 做数据预热

系统启动时，提前将热点数据加载进 Redis。

#### ✅ 3. 异步延迟双写机制（预防性刷新）

- 提前批量刷新即将过期的 key
    
- 配合队列/定时任务异步更新
    

---

# ✅ 总结对比表

| 问题  | 触发条件                  | 影响          | 解决方案             |
| --- | --------------------- | ----------- | ---------------- |
| 穿透  | 请求不存在的 key            | 每次穿过缓存直达数据库 | 缓存空值、布隆过滤器       |
| 击穿  | 热点 key 过期瞬间           | 大量请求同时打穿数据库 | 分布式锁、永不过期 + 异步刷新 |
| 雪崩  | 大量 key 同时过期或 Redis 宕机 | 请求洪峰压垮数据库   | 随机 TTL、预热、限流、熔断  |
redis+redisson防击穿模板
```java
@Service
public class CacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    /**
     * 获取数据，带缓存击穿防护
     */
    public Object getDataWithLock(String key) {
        // 1. 先查缓存
        Object cacheData = redisTemplate.opsForValue().get(key);
        if (cacheData != null) {
            return cacheData;
        }

        // 2. 缓存没有，尝试加锁
        String lockKey = "lock:" + key;
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // tryLock(等待时间, 锁过期时间, 单位)
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                try {
                    // 3. 双重检查，避免重复查库
                    Object doubleCheck = redisTemplate.opsForValue().get(key);
                    if (doubleCheck != null) {
                        return doubleCheck;
                    }

                    // 4. 查数据库
                    Object dbData = queryDB(key);

                    if (dbData == null) {
                        // 防止缓存穿透：写一个短期空值
                        redisTemplate.opsForValue().set(key, "NULL", 1, TimeUnit.MINUTES);
                        return null;
                    }

                    // 5. 写缓存（加上随机 TTL，避免雪崩）
                    int ttl = 30 + new Random().nextInt(10); // 30~40 分钟
                    redisTemplate.opsForValue().set(key, dbData, ttl, TimeUnit.MINUTES);
                    return dbData;

                } finally {
                    lock.unlock(); // 释放锁
                }
            } else {
                // 获取锁失败：稍等再读缓存
                Thread.sleep(50);
                return redisTemplate.opsForValue().get(key);
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 模拟数据库查询
     */
    private Object queryDB(String key) {
        System.out.println("查询数据库: " + key);
        return "value-for-" + key;
    }
}

```