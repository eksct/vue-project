## 目录

- [七大原则](#七大原则)

  * [单一职责原则](#单一职责原则srp-)

  * [开闭原则](#开闭原则ocp-)

  * [里氏替换原则](#里氏替换原则lsp)

  * [依赖倒置原则](#依赖倒置原则dip-)

  * [接口隔离原则](#接口隔离原则isp)

  * [合成复用原则](#合成复用原则crp)

  * [迪米特法则](#迪米特法则l-of-d)

- [创建型设计模式](#创建型设计模式)

  * [工厂方法](#工厂方法factorymethodpattern)

  * [抽象工厂](#抽象工厂abstractfactory)

  * [建造者](#建造者builderpattern)

  * [单例](#单例模式singleton)

  * [原型](#原型模式clonepattern)

- [结构型设计模式](#结构型设计模式)

  * [适配器](#适配器模式adapterpattern)

  * [桥接](#桥接模式bridgepattern)

  * [组合](#组合模式compositepattern)

  * [装饰器](#装饰器模式decoratorpattern)

  * [代理](#代理模式proxy-pattern)

  * [过滤器]

  * [外观](#外观模式facade-pattern)

  * [享元](#享元模式flyweight-pattern)

-[行为型设计模式](#行为型设计模式)

  * [解释器](#解释器模式interpreter-pattern)

  * [模板方法](#模板方法模式template-pattern)

  * [责任链](#责任链chain-of-responsibility-pattern)

## 七大原则

### 单一职责原则（SRP）  

指类是专门负责某一个方面，如连接数据库,专注处理前端请求  

明确划分职责,同种类型操作聚合  

  

### 开闭原则(OCP)  

软件实体对扩展开放,对修改关闭  

扩展开放是针对提供方,修改关闭是针对调用方  

调用该软件实体的对象无法对其进行修改,提供该软件实体的对象可对其扩展  

  

### 里氏替换原则(LSP)

父类(基类)出现的地方,子类一定也能出现  

即子类可以扩展父类的方法，但是不能改变父类的功能  

子类可以添加独有的方法  

子类不能重写父类的非抽象方法  

子类重载父类方法时，参数列表需要比父类宽松  

子类实现,重载父类方法时,返回值需要比父类严格或一致  

  

### 依赖倒置原则(DIP)

高层模块不依赖底层模块,他们都应该依赖于抽象,抽象不依赖细节,细节应该依赖于抽象  

用户操作类包含接口或抽象类，而不是一个具体的实现类---用户操作类本来应该依赖于实现类，但是现在依赖于抽象  

而操作的细节只需要实现抽象,所以细节也依赖于抽象  

  

### 接口隔离原则（ISP）

客户端不应依赖于不需要的接口  

即实现类不应依赖于有多个不需要实现的方法的接口,若出现此状况,需要对接口细分  

  

比如一个全体车型（包含自行车）的接口,内部有获取品牌,排放量,发动机型号  

汽车类实现该接口时能够实现品牌,排放量,发动机型号  

自行车类实现该接口时只能实现获取品牌  

这时就要对全体车型接口进行细分，分为汽车接口和自行车接口  

  

### 合成复用原则(CRP)

优先使用组合对象,而不是通过继承达到复用的目的

  

通过继承实现复用的耦合度太高,并且会将父类的一些细节,如字段，方法直接暴露给子类，不安全。  

所以在需要复用时，优先考虑组合对象（比如把组合对象先放到类中作为一个成员，或者是通过方法传入组合对象并调用）  

  

### 迪米特法则(L of D)

  

每一个软件单位对其他单位都只有最少的知识,而且局限于那些与本单位密切相关的软件单位

类/模块之间的交互越少越好.当一个类发生改动时,与其相关的需要尽可能少的受到影响  

怎么说呢……  

模块需求的数据如果能在外部处理完,就尽量将处理完的数据传入,而不是传入一整个对象后在模块内操作

比如我需要调用某个方法获得一个对象内的数值,不应该把对象传入方法,而是直接把数据传入方法

## 创建型设计模式

### 工厂方法(FactoryMethodPattern):

提供对应的工厂类,调用其创建方法创建对象,将某一类对象的创建聚合到一个工厂对象中,这样当被创建的对象类遭到修改时只需要修改工厂类,不需要大面积修改。------简单工厂模式  

简单工厂模式违背了 ‘开闭原则’,如果需要添加新的创建,就需要对工厂类进行修改.即调用方对工厂进行了修改。  

升级到工厂模式后,若要增加新对象则需要新增一个工厂类  

如果是一条流水线,每个部件都要创建Factory的话,会有很多类，比较冗余  

以个为单位  

### 抽象工厂(AbstractFactory)：

以组为单位,封装了一组对象的实例构建,但调用者若需要新的构建,需要修改抽象工厂类,违背了’开放封闭原则’  

### 建造者(BuilderPattern):

建造者模式更加关心对象每一步的配置,当配置完后再进行对象的创建  

一般情况下如果用构造方法初始化对象,在需要初始化多参数时，会显得十分冗长,可能导致逻辑混乱。  

使用建造者模式则不进行对象的直接构建

### 单例模式(Singleton)

对象只有一个实例,同一个类始终只有一个对象来进行操作.  

饿汉式:

- 在加载前已经创建好了。我不用,但是我一定要有。

```java

import SingletonPattern.Singleton;

public class Test {

  private final static Singleton Init = new Singleton();

  public static Singleton getInstance() {

      return Init;

  }

}

```

优化:

-可以使用枚举类,这样不仅解决多线程问题还可以支持序列化

懒汉式:

- 在需要时检查并创建对象  

- 因为是在方法中创建,多线程下会导致创建实例不一致

- 可能创建垃圾对象

```java

import SingletonPattern.Singleton;

public class Test {

  private final static Singleton Init;

  public static Singleton getInstance() {

      if (Init == null)Init = new Singleton();

      return Init;

  }

}

```

  

优化:

- 可以给方法加上synchronized关键字加锁,效率会低

- 对 Init = new Singleton(); 进行加锁,仍有可能出现判空并新建的情况

- 对 Init = new Singleton();加锁并在内层再次判断是否为空,需要对象添加volatile关键字对其他线程可见

- 在静态内部类中写好对象,由于类加载机制,静态内部类中的对象不会在一开始创建

  

### 原型模式(ClonePattern)

  - 即对对象的拷贝,java中由Cloneable接口提供的clone只能实现浅拷贝

  - 浅拷贝只复制值或者对象的引用

  - 深拷贝会复制对象的基础属性,并克隆一个新对象

  - 专注于对象的克隆

  - 必须实现 Cloneable 接口

  

## 结构型设计模式

## 适配器模式(AdapterPattern)

- 将一个类的接口转换成客户希望的另外一个接口

- 通过接口转换，将一个类插入另一个类系中

- 继承或依赖实现,但由于java是单继承形式,尽量使用依赖实现

## 桥接模式(BridgePattern)

- 若类的种类多样,涉及到多维度考虑,则可以使用桥接模式

- 对象之间使用组合关系,以达到维度之间的独立性

- 比如奶茶与规格,若每种规格的奶茶均创建一个类,则每新增一种奶茶就需要新增三个类

- 加入配料的话类的数量更加难以想象,若还有后续处理的话则继承与实现位置会越加冗长

- 使用桥接模式只需要在奶茶中使用规格抽象,独立创建规格类并在初始化时载入规格,这样就不会造成需要创建多个类的问题

- 把抽象化与实现化解耦,使得二者可以独立变化

### 组合模式(CompositePattern)

- 参考文件夹与文件的关系,文件夹包含多个文件

- 树状关系表示,每个非叶子节点均为文件夹,叶子节点为文件

- 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

### 装饰器模式(DecoratorPattern)

- 允许向一个现有的对象添加新的功能，同时又不改变其结构

- 动态地添加新的功能

- 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

- 强调增强自己--强化自己

### 代理模式(Proxy Pattern)

- 为其他对象提供一种代理以控制对这个对象的访问

- 当无法访问某个对象或者访问困难时,可以使用代理模式

- 代理类需要保证客户端使用的透明性

- 强调别人帮你做--让代理类帮你做事

- JVM可以实现接口的动态代理,其他类型的代理需要使用其他框架进行

- 代理模式与装饰模式思想不同,但是解构类似

### 外观模式(Facade Pattern)

- 隐藏了整个系统的复杂性,提供了一个门面给客户端进行交互.

- 使一个复杂的系统能够简单的使用

- 比如去医院看病,流程很多.如果有接待人员那这些事情都会被接待人员处理,病患会方便许多

- 病患是客户,接待人员是门面

### 享元模式(Flyweight Pattern)

- 减少类的创建量,以减少内存占用和提高性能.

- 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。

## 行为型设计模式

## 解释器模式(Interpreter Pattern)

- 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

- 可利用场景比较少

- 文法是吧(被干碎)

- S -> F | F-T | T+F

- F -> T*F | T

- T -> F | id

## 模板方法模式(Template Pattern)

- 一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

- 定义一个骨架,将一些步骤延迟到子类中实现

## 责任链(Chain of Responsibility Pattern)

- 为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦

- 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。